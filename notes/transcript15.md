### 0:00 - 5:00

Oskar: any volunteers here. We have about 27 people here. Igor Igor do you want to take notes?
Corey: I will take notes.
Oskar: great thank you so much cool. Im are you live on YouTube yet ?
Status.im:  I'm having some issues with YouTube but I'm going to say I recorded it and I'm working on getting it started right now so if anything
I will upload the video later if it if I'm still running into some issues yes sir yeah.
Oskar: Okay
Igor: There is a notes doc in the zoom chatroom. 
Oskar: YEah. It's there.
Igor: In zoom ?
Oskar: Yeah. In the group chat and in the status core dev channel.
Igor: Oh yeah. I see the notes. Core dev agenda. Cool.
Oskar: cool so yeah thank you and welcome to the 15th core dev call. Let’s start wiht some brief updates on things that hasn't been mentioned in the last Town Hall that you think other people should know about and then we could talk briefly about partition whisper topic compatibility, Status Go as the next package, briefly on KS unicorn, quickly follow up with better pull request process and then we had a call month or so ago and then if there are any announcements. Before we get started, is there anything else people would like to talk about? All right cool. So will start with the small bits. So a set of things new, that hasn’t been mentioned in the last Town Hall, um.. Sticker Market?

# Sticker Market

Julien: yeah pretty much nothing in the sticker market front. We are almost done, just waiting for contract audit. So not much on the development side.
Corey: We gonna be waiting on coordination on the troubled bits which is starting. Meeting with them this weekend. Then they've already looked at that audit metrics that I set up that looks at all the functionality and understand that attribute talk and sticker market are the first on the list.
Oskar: Alright. Tribute to Talk. 

# Tribute to Talk

Eric: Yeah the contract was updated so that it can be deprecated in the future and the message personalized message for attributed talk has been replaced by a hash for ipfs so that instead of just having a message, we can have a bunch of metadata including the message and store it on ipfs and yeah that's it for Tribute to Talk.
Oskar: Dapp Store.

# Dapp Store

Corey: Real Quick about the Sticker Market, I wanna ask, there were a couple changes that were that were happening with regards to the contract. Are those done or are they still in progress?

Julien: Right so Ricardo did like a very simple change and it's done as far as I know. So yeah it should be already in the report now.

Rachel: What about the changes to controlling the package? It was on list.

Julien: Right so there is this change that Ricardo did recently.  I think he sent an email like last Friday or so. I don’t remember and I understand he did it.

Rachel: Okay.

### 5:00 - 10:00

Oskar: Alright. Dapp Store.

Oskar: Okay. Teller Network.

# Teller Network

Iuri: So we are trying to put the dapp in Rinkeby and we are debugging some deployment issues that are happening namely with some caching issues that was happening on the client side. We fixed this issue with the S&T token that we found. I mean we did a little bit of a lot of small fixes here and there and and was the goal right now is to get it working 100% in Rinkeby.
 
Oskar: Alright. Network Incentivization.

# Network Incentivization

Igor: So yeah basically the goal for this week is to make an end-to-end very like simple proof of concept. So essentially the whole sort of flow from running a mail server in our case right now it's a status node and registering it for now while it's some sort of a closed beta and then using it in the app so essentially to have this flow of no incentivization but it is the flow around your custom node and you can use it in status in a more or less convenient way. This kind of this side of it and we started with a contract that. Actually Andreas started and we have a help from Ricardo as a mentor. Essentially on this. Yeah that that's it and then we'll work. So right now the contract part is yeah it's even deployed but we'll work on status going status react integrate with this contract. Yeah that's the next step. And then we'll do some implementation there or like some probably stab implementation of subscription just to have some UX feedback from it. That’s it.

Oskar: All right. Cool. Token economics. There was a great presentation  at last time also. Probably not in the new update or so I guess. 

# Token Economics

Barry: I wasn't prepared to kind of presented anything especially since I kind of monopolized last week's call. But yeah there's there's still a lot of ongoing work. There's you know books I would just stress that I would have teams continue to think about sort of well one on a broad level what's the probability, what are the factors that influence the probability of a project failing and then just about you know your the your own specific drivers a value yeah and we're thinking about maybe starting to publish some of our research maybe as blog posts to try to get a broader feedback yeah outside of status.

Oskar: Awesome. Core Improvements. Is there anything outside of POC unicorn preparation.

Igor: Yeah it was 1 11 0 release testing and things and we actually decided that after this discussion Disqus post to have a no-go for the current implementation of topic partitioning. We'll discuss it later but yeah that's just for the information. So we will not enable it in 0 11 0. That's all for me.

### 10:00 - 15:00

Oskar: Cool. Right. I can do protocol briefly. Um I don't thing I mentioned something. So we had we had this panel in if you see a few weeks ago and that sort of work is ongoing to some more long-term mix that kind of based approach and we are trying to collaborate with with some more groups of people and so on and we're gonna have a call similar to the fm2 call quite similar to this call. As we discussed, it’s gonna be tomorrow and then we'll have it every other week. We'll see how it goes. And then there's been as some of you have seen, some sort of the data synchronization. Resource Log, I started a week or two ago with the goal of sort of taking a step back and looking at sort of existing literature when it comes to data replication and so on to sort of see all the various alternatives and try to categorize them and understand the trade-offs more in a better way. So I'll keep working on that and getting a better sort of comparison and then see what comes out of that. And then one sort of there's a better on say of that then resume proof of concepts and figure out a plan for getting it into Dapp. And if anyone has any comments or thoughts on that either here or we can do it in private.

Oskar: All right. cool.

Barry: So liquid funding. There's that initial there's the project page that that's basically done where a project it can be displayed, um sort of in a more Kickstarter like format and now there's a actual checkout for for the back this project completed I think maybe perhaps a stretched goal to try for it is to create a page that would easily allow someone to create their own project page, not just view one and back one. Maybe in time for build week and we might be able to dog food it with different people and teams inside of status store during build week uploading their projects to using liquid funding. So that sort of a stretch goal we'll see if we can get that we can get that built in this next week or not.

Oskar: All right. Anything from core browser or chat. Anything from desktop wallet or key card.

# Chat

Eric: I can make a small update for chat. What we've done that concerns other teams. So there is the the typographic component that has been implemented. So from now on it's better to use this instead of font type and font font size and all these font related parameters when implementing CSS unless it's a very specific component that doesn't have a known typography. But basically all the typography available in Sigma are usable through the typography attribute in CSS. And the other thing is that soon we will merge a PR that introduce system tags which is now the preferred way for adding information to context like is the contact blocked or added or contact request has been received, that kind of stuff. And that's all for me.

# Browser

Julien: I can say a few word for the browser team. I was meeting them before. Um so yeah because we are mostly done with sticker market, now we take this opportunity to push a bit more extension and the short term goal is to have extension out of alpha so that's behind the flag and usable directly. So that means mostly nailing error handling and permission mechanism. And also with we plan to crucially a little bit the developer experience just to make sure it's easier to create extension. So if you have any kind of an opinion or ideas around how to handle permission or error handling, I'm interested in your feedback.

Oskar: I'm curious, is there any plan or research around making sensors so so you could use the DNS of different environment whether that would be like some JavaScript API or I don't know what it would look like but making it so it could be implemented in other clients where closed script is not so first-class system.

Julien: So it's not like the target we have is short term but it's definitely something we keep in mind so just to make sure that we don't introduce feature that would make this more complex. 

### 15:00 - 20:00

Julien: So I think that there's nothing that prevents implementing the runtime in different languages because it's mostly data and then semantic applied to to this data and there is no our dependency on JavaScript for instance as of now. So we are definitely something that we keep in mind.

Rachel: It's also worth plugging that Julien did a swarm  write up for this next phase of extensions to kind of lay out some of the short term short term which is in this one folder.

Oskar: Awesome. Anything from wallet or key card.

# Key Card

Guylouis: Yeah for key card when she finishes the Android integration in VPN. Last week we still had to work on the Dapps transaction signing. Also Geth integration is almost done under Iser Ping from Ethereum team. It’s progressing very well. And we are getting in a research phase to a low point of sell use cases within Dapps through either payment I mean either through QR codes or with Kiko. And there have been a brainstorming about that last week that I'll post right there if you want to comment. And Goran, are you here?

Goran: Yeah. Yeah. Regarding the wallet we are reprioritizing. Basically will push smaller incremental UX improvements. For the wallet side, some of them require for the point-of-sale addition, some of them outlined by Carrie previously. Yeah so that's that's that's pretty much it on the on the wallet side UX improvements coming up. Also fixes yeah.

Oskar: Cool. Yeah. Any from from QA or doubters. All right oh good. Yeah.

Anna: For QA, mostly testing for like the arts for mobile application mostly for crouse unicorn day and for the future release. So fixes for these blockers. There is pending test automation. Pending means we're waiting for South labs for support to find out the reason why it takes so long to start application and on the hours. So it's like almost a week or even two weeks that we are waiting for them. What else, yeah that's basically it.

Oskar: Right. Embark or Nimbus.

Iuri: Embark had a small release last week. I guess. And and we released a new website.

Oskar: Cool. Did I miss any group of people?

Hester: Maybe from design side Oscar.

Oskar: Oh yeah.

Hester: No questions. A request. We are looking for a designer to join the team as Dennis is leaving. So if you know any designers yeah please do let us know so we can reach out to them.

Oskar: Great. Thank you. All right cool so with that let's move into the first topic. So this one is about whisper topics and the partitioning of them and some questions around sort of compatibility and so on. Who wants to give a brief summary of where we're at with that and so on.

# Whisper topics and its partioning

Igor: I can do this. Basically a long story short, it used to be that the decision was made like way back when to use a single whisper topic for all the one to one messages and all the group chats because they're based on one-to-one messages and essentially the issue with that it's it's great for privacy because each node is downloading each other nodes traffic which is good because you can figure out who's talking to whom but the bad is yeah because each node is downloading each node’s traffic. 

### 20:00 - 25:00

Igor: And I don't know we had this outage of the Hong Kong mail servers a while ago and before that we had an issue with traffic draining on East Berlin I guess it was. So it was all started roughly at East Berlin when we looked at this issue. And then yeah essentially we figured out that it's right now with our current user base is around like in on a normal day it's around 100 megabytes of private messages per day and each one has to download everything and that means that if we just if when we release if we will have like 10 times more users, it will means that each one will have to download the gigabytes of traffic per day just for private messages which doesn't look like a good idea. So we decided that we will need to somehow like target this. And one of the idea was like again it was a while ago. It was summer-ish PR from, I don't remember who was it like Roman or Andrea. There was a PR with I guess Andrea. The first PR.

Oskar: yeah

Igor: Yeah. It was the first PR of like actually using the partition topic instead of like, essentially each each person will have a personalized list of topics he listened to based on his public key, in some in some way. And then this PR was wasn't it got some critical say and then it was like stopped and closed. And then after this issue with mail servers that was in December I guess. Then we decided to re like re-evaluate this and I created a post on Disqus about what do we want privacy or do we want like an efficiency out of traffic. And then this post didn't get any attention almost at all. And I guess one day Ricardo, Adam and Andrea were participating there. more or less. And then essentially we just figured out there we came to some kind of consensus how we want to build this partition topic. So without like we try to tell everyone about it. But again it was mostly ignored. And then yeah we decided to actually split this this topic. Went ahead and then we decided to split this into multiple releases. So the first release would essentially listen to this split topic and also to the old topic but never sent anything to it. And then the next major release which was what this one. Supposed to be this one. Supposed to start start writing on it. And then we also try to coordinate the comms. So that the old version 0, 9, 33 won't be able to receive like one-to-one messages from the newest one 0 11 0. So that's what we did and then essentially I wrote a post about post mortem about what why we did it. And then we got this feedback as well about the current implementation of partition topic isn't I mean it's not that bad but it's not the simplest one and it's not the simplest one to re-implement it other languages than JavaScript or Clojure script or anything that's compile to JavaScript. So we decided that we'll postpone this partition topic. And yeah we’ll essentially change the algorithm. We will still do this. And it will be a breaking change will that we'll probably try to split across multiple releases so it's not like just one release won't be able to talk to another but like release we'll be able to talk to one or two releases before that. But we'll do it in a more I'd say re-implementation friendly way, because yeah, it's a bit of a route decision and it's a little bit tricky to actually change it without breaking the backward compatibility especially if you if you don't have your nodes always online. So that's roughly it.

### 25:00 - 30:00

Oskar: So I have a question on the backwards compatibility aspect which is like I was saying there's we don't think there's any way we could maintain backwards compatibility even though we have multiple devices on like it’s a because you could imagine that you that you you still have support sending of a discovery topic but once you discover another device is using the same topic than you would use that. 
Is that something like that not feasible at all?

Igor: I mean we thought that essentially the trade-off of implementing this that this kind of appeal will will be worse than the disease. It's curse. 

Andrea: So it's an issue because so that that works as long as we use the same technique to we try to make a group chat of different topics and you know straight away we got an issue that because it's not like if anyone has got a device with no other release then you know like that device won't be receiving any more messages. So it only works as long as the user has all the device up to the current release and you know like that's that might not be the case especially with desktop where the last release was 0.9 whatever. And it's so and any new device we don't do the device to device. It’s really mostly costs to public key. So we don't know which version are they running. And so we could do that. It would mitigate you know obviously the breaking change but it would not we still have the same problems.

Igor: I would say that it would be worse because then we'll have these bugs or colon code bugs when there is one like version that doesn't work and one does work for the same account, of the same user and it's much harder to communicate this.

Andrea: Dedugging. yeah.

Igor: It's much harder to communicate because right now we can just tell it's okay if you have version that starts with 09, please upgrade it. Right but if if you don't do this and try to yeah it will be much harder to coordinate this thing. And it it will mitigate it somehow and of course this breaking change is not that bad because A we are in beta and B we can revoke bills on iOS and Android. It's much worse than on desktop of course but it's it's far from being released. 
Our plan was essentially as soon as we release this incompatible change then the old versions will be expired. And both has fight for a place in playstore. So for those who install these versions, they won't be able even to use them anyway. So it's it's sort of a mitigation. Well a bad one and then I wanted to ask as well since we will probably will have to break this like we want to delay it for the better algorithm for partition topic. For simpler one and is the one that it's easier to implement it in other languages than JavaScript.
The question is, is there anything else if we are still breaking the compatibility is there anything else that we know that might require breaking them. Possibly because we might want to just bundles a few things together and fix them. Yeah. The as the same package.

Ricardo: So there is some handshake in these private messaging communication. If there is couldn't be a dis handshake informing that the client is using this new protocol of partition and topics. And if they don't communicate this handshake, they just considers that it uses the old generic topic wouldn't wouldn't be that possible? And also..

Igor: It works well when both devices have always been online and if you have mobile communication then you're mostly offline. It’s you don't have handshake directly to the one who you are you talking to. You you just throw messages into the network and sort of that's it. And then the other person might be online and receive them. Or it might not be online and then mail server receive it.

Ricardo: We could have like some additional message then like a protocol message that is sent using the old topic and and this could inform the these new clients to use this because then if you are a new client and you see that you are receiving a message in the old system maybe you could ask them. I know that this could not be the best thing.

Eric: But if you are listening to the old one you're wasting your data because..

Ricardo: yeah yeah 

Igor: yeah right. That's the point of not wasting data and the second it doesn't solve the issue when you have one like you have two version like you say the desktop, it already supports it and then the mobile that doesn't. And they have the same key. And we don't have a client information. We just know that yeah we sent something to a public key and this public key might be like five devices with different versions. So which versions will you choose?

### 30:00 - 35:00

Oskar: So maybe there is just two points right like one is like why we would want to have compatibility at all and I think this is a great opportunity to practice it and get better at it and like sort of figure out the testing and and the the scaffolding we need to make sure that we can sort of stay compatible because it'll only get harder as we move along. And then the second point on on like how like we do have some information about device syncing like you know which device you're syncing with. So it doesn't seem like, I understanf that you would require some additional work but it doesn't seem like it's impossible even though it's multi-cost space is on because we still have device information. And then on Eric's point with respect to the amount of data you wouldn't actually because if most people upgrade then it would be pulled into another topic.

Igor: But where would you backup the device information?

Oskar: When you sync, you sync devices right?

Andrea: So you know that you do have that information. But the one-to-one chats don't rely on that. So like group chat do for example group chat would be easy to you know to do that. Because essentially you can you can just do that. Because it's a device to device communication. Well really like one-to-one they're not at the moment.

Oskar: So there's a problem with with how one-to-one, I mean you should not be the same essentially. Like why is there really a difference?

Andrea: Oh just because you know like we haven't gone live with BFS before one-to-one, well, group chats are using it.

Ricardo: So regarding the waiting more for this feature, I think it's a smart move because this is a we should probably discuss better. So I remember this discussion was like when the first problems arise, I actually commented on it, some ideas on how to solve. And actually I think it's just the same thing but I maybe got some details wrong. But I wanted to participate in your discussions about this and to see what we can do like to have a better solution. So I think everyone that that have the interests can can collaborate on this, because these problems can be solved with a lot of creativity just as always.

Andrea: Once you have device-to-device communications, of course you know like the method that we mentioned it's possible, so that it's trivial. It's just like at the moment we were literally on top of whisper. Whisper does not have this multicast you send to a public key and anyone with that public key you know like can you know essentially decrypt it. Thing is there's no way you can do it with whisper, because anyone can spin up a version of the previous version of the app and then you miss, you're gonna miss that message.

Jacek: So why not for a second we go back to point that Igor made that we can be happy that we can force users to upgrade. This is actually kind of the problem. Every time you force the users to upgrade, that's that's a coercion avenue. That is how that is how vulnerabilities get introduced involuntarily for users. Basically if you want to get an update out to users, that's how you do it. You can use sort of masquerade ot as a protocol update or whatever right. It's a very classical thing like Skype does it when they became centralized and so on. And everybody just happen to accept right. So we should be a little bit careful about being too happy about the fact that you can force for example iOS users to upgrade. Infact I think we should be creatively looking for ways to make sure that that is not possible.
 
Igor: Yeah and I'm happy to discuss the possible solutions right now. Because so far one of the like I think pretty valid critiques that Andrea points out and I totally back is that people tell that, “ok you don't please don't do this”, and there is no essentially dialogue about, “oh there is another possibility”. It's very easy to just tell, “Okay. Never break compatibility.” So what are we going to do? So we have this protocol thing here that is realized on I mean it's obviously first an abstraction, like because we shouldn't use whispered topics directly in our protocol. Period. But that's another topic on this. So we have this very rude decision that was made for, yeah Eric recently wrote for probably reliability reason. So and that's yeah and we don't really have devices online all the time. So what are the good solutions how how others usually decide this in mostly asynchronous communication.

### 35:00 - 40:00

Jacek: I think the first lesson here would be that every time protocol is designed, you need to think about the upgrade path ahead of time, to provide one. That makes your life so much easier and I think that's that's a little bit Oskar's point that we need to practice switching particles somehow and the classic way of doing that is designing the particle in such a way that that it can be upgraded right. So if we are introducing this breaking change, I think maybe a criteria for it would be that we we also see a past upgrade to the next one after that. And this then we could claim that this was like the last breaking upgrade with the world. Whatever right but that that's the kind of takeaway that I would love to see from any post mortem.

Eric: I just wanted to say that there might be a way to do it without breaking change. If Oskar's assumption is right that over time the discovery channel will be less overused as people upgrade. So then we just could just revert to what the protocol was initially doing which is use the discovery to pick any for contact requests and then switch to a random topic after the first reply, and then there is much less traffic in in the discovery topic and that doesn't require an upgrade for breaking change.

Andrea: I think all these solutions always direct to the same issue. At the moment the way we do multi device support which is basically relying on the public key you know have the same problem. So you really either rely on some state I random topic we received or you're gonna miss messages. If you have one device at the upgrade to the run topic snd you add the new device, you know the other user would not know and it's gonna send the topic it's gonna send a message it's gonna send it to the random topic. Yet the device that has no synchronized state will not receive it. Of course you can you know have device thinking that it will help but again you know let's not call it breaking change because it would be essentially.

Ricardo: I agree with what Eric said about using the this common topic as a handshake only topic for the new protocol. And then the older versions would ignore these messages because they would not understand them. But they they would then use this older topic for everything. If somehow the mail server could filter the messages by size, we could make the new clients only search for ask for a message in that topic that that are smaller than a certain size because maybe this handshake message would have kind of the same size and probably would be smaller. Then you don't need to download everything. I don't know if that's possible.

Igor: All whisper messages are same in size because of privacy. They are either of this certain size because of the content or there is a padding that is added to make all the messages roughly the same size so, no it wont work.

Oskar: So Andrea, you were mentioning the difference between group chat and one-to-one chat. What do you see as the path to making what more one-to-one chat more like group chat which it kind of is like it's a set of devices.

Andrea: Yes like that to me like you know like we should just like the fundamental problem is that we use that system for device you  for multicasting. So anyone with a public key will be able to you know basically, no matter what client is using, no matter which version is able to decode those messages. And that's really is not upgradable you know essentially. Because you know like because it is embedded in this in whisper. So you know essentially like if you want to move to device to device basically sending, its gonna come at the cost of course because it means that you know like if someone you know it's the same as you see with group chat. So it's essentially now if you mean group chat, if you create a new device and you don't sync it and you are in a conversation or another group chat you want to receive those messages. 

### 40:00 - 45:00

Andrea: So what we did is that there are techniques so that that information is propagated but that information which is similar to protocol negotiation. But the information needs to be propagated extensively. So there is the possibility of missing messages because you just spin up your device you and so like okay we're gonna move one way to do it is to move more towards device-to-device communication rather than this multicast by public key. And in that case yes you can use protocol.

Oskar: So I agree to it that there might be some edge cases where if you don't look at you you recover an account with an old version and you haven't synced with the device and you do this like several months off that. Yeah there might be some edge cases. I think that look going forward like having something that whisper topic as a kind of transport transport property such that we think instead about it in terms of syncing between devices that means it shouldn't matter for upgradability if we change out whisper or whatever because that's not actually what we, it's just one form of transport. There are multiple forms of transport. So I think if we have that, then we have device abstraction then we can have sort of a path to upgrade graceful upgrades in the future.

Andrea: Yeah that that would certainly help. It would be a bit more sheltered from these problems essentially. Because now the problems that we are too close to the transport layer essentially.

Eric: I have a question. Is the topic information part of the encrypted message? I mean if you take a message and you change the topic and put it back, is it still going to work to decrypt it?

Igor: We can sign but not encrypt it.

Eric: Because then we could encrypt because then we could could we simply use the old mail servers the one that are already hard-coded in the all those devices. Has like legacy mail servers and we make a new fleet and this fleet would take all messages from from the new devices, new topics and put it all in discovery topic. So that like the old devices will have everything in discovery to pick. So they won't miss anything but I mean ..

Igor: I guess the signature won't signatures won't match but we can do it a shot and check. It probably is signed with the topic and I dont know how whisper will probably will just reject envelopes with if you tamper the topic. But we can take a look because it's actually a solution. if that's what should go.
 
Eric: Yeah. Or the other one would be to allow because right now you cannot send a message if you don't listen to to a topic but we could do a we could allow it for for this topic and just drop a copy of the message on that topic and never listen to it. We could effectively ignore it form for. Yeah that would be good I mean yeah anyway.

Oskar: There was another point if it was a good point it was brought up which is the lack of engagement. Just process speaking I think that partitioning topics is like a great way to optimize the bad way from the second. It is a reasonable thing to do and it seems like something that generally could be done local sort of local form decision-making within this form. I think that concern might be when it comes to something that breaks the protocol so that it impacts sort of more groups of people and I think if that is made more clear or if we sort of we want to separate out all of this and have it be a sort of different cultural process and different technical process where we're changing the protocol and we need some form of consensus perhaps in these calls, perhaps in some other form. That's something we're going to work on over the next few weeks and months to sort of we have some haphazard documentation but bring it more together and also created this specs repository and then maybe we when we have questions like the these, then we can bring them us up in a quarter call as of come prepare with a proposal for changing some of the protocol in some way and then we can discuss it. I think that would separate out the things there are sort of swarm implementation specifics for certain trade-offs versus things that impact the entire protocol. And if people have any thoughts on that.
Igor: I think that's a good idea in general. So we should probably do some you didn't some for the fist.
Eric: I I don't have a thought but I'm wondering so how do we make this decision whether we accept break breaking protocol or not? How do we consider
Oskar: Yes so we'll have to figure out, I think that for those who been here for it for like a year or year n a half, we had this one process and it's something like this but in a way like similar to the hyphen improvement process or bittorrent improvement or Bitcoin or EIPs or whatever and it says they're having a process like that where there's some form consensus among some sort of core achievers or whatever it looks like and that will also be its own sort of SIP or whatever you want to call it. Atleast that's how I'm thinking about right now and I think it is a pretty scalable and and and tested process for protocol changes in general and something that's generally used. So that's how I imagined. Specifically how decision will be made or when something will move from draft is always something we can discuss further.
Ricardo: So it would also be possible to opt-in to the users to opt-in this and owns now the protocol is not used anymore. But of course this opt-in should be explaining the user what changes and what's why it's better that provides less privacy and etc.
Oskar: So so this would be so this would be more about client implementers and then maybe it's the Status app would choose to expose such options but across I mean it's more amount of such clients for example like BitTorrent they introduced deep support and all clients have pretty much implemented because it was useful and then you added like a private field to have private trackers and local peer discovery and these types of things and it's like enhancements but it's up to each client how you want to how do you want to deal with it and most clients will likely expose it in some way if you want to use THT and then there's all these considerations and so on so that's but that in itself could be a local decision for the status app and it would be separate from the protocol. So the idea is to think of them as two sort of separate animals kind of. That'll be a help in any insights or or thoughts he would like to add to this.
Jacek: Nothing new really I mean we've talked before about make enshrining the protocol into a separate entity so that when you discuss a protocol changer or so not from a Unicode perspective and not with a code mentality but rather with a protocol mentality. And I think I think we already agreed that moving to moving the protocol out from the codebase completely including all these little quirks would be the first step and then developing the protocol based on that document obviously with the reference of the mutation and so on but like approaching it with this slightly more procedural approach which includes these various steps that that the teams and so on have and tips and whatever, gives it the appropriate social way so that everybody's on the same page and it also gives the community an opportunity to weigh in especially if if you consider that they might not be fluent in you know both called JavaScript Clojure and in the rest of the technology stack that we happen to be using. 
Ricardo: So maybe we could support a Java version that would be a good option because Java is a is a really clear written language and like mostly understood widely. So I am volunteering myself of updating Etherium J to support new whisper and then to start making rising up mail server or something. So but I'm doing that in free time. So maybe this could this effort could help in that the protocol definition because having these implementations just make it to reach
Oskar: sorry Ricardo. I want to make sure we don't stray too much into protocol and disorientation so on. I think go back to topic with whisper finishing and so on. Like what's the specific steps we want to do here. I think one is just roughly capturing the current protocol and so these types of changes would have sort of carry more weight. So if there's gonna be some some kind of breaking compatible or whatever that is sort of formatted in in a way that's outside of the code base. First help in this fixed repository. Do people generally go with that?
Ricardo: I think that the next step will be to make a swarm just to resolve this issue.
 Oskar: Yeah yeah. It's just a question of time frame because we have this sort of semi specified thing living in Dapp right now and then draw certain core pressures that sort of means that some changes have to be made sooner or than later. So it's a question of find the balance between having like I don't know protocol specification or whatever for everything versus sort of making sure that the thing we already have in the Dapp and then doing graceful changes of Dapp, that sort of dealt with properly.
Igor: Yeah I mean there are few things that you started the second implementation and goal which we were planning to have a like a separate, separate repository sooner or later. And some documents and it's already helped atleast finding this issues with the Java JavaScript specific things in the protocol. I hope we will continue with that. Ricardo is working on this but, yeah the question is yeah what we do we in the short each term okay. So probably the other communication better. That would be good from my side as well. 
Oskar: So can we it's just some way we could have some kind of proposal fraud to deal with it to buy more device to device spaces, like what the path that looks like and how how we think that the last breaking change or whatever we make will be compatible with the change in the transport completely that's one thing. And another thing is if there is some creative solution we can do right now to reduce bandwidth, for example by by not send what we have whatever.
Jacek: Would it be hard to revert the breaking changes if this creative solution is found so that we can go back to being compatible with the older versions?
Igor: I guess we always need some sort of discovery topic anyway. So there is some new client that goes back again to using this single topic, it's maybe will work by default as I understand. It it costs nothing to listen to these topics. Or that right out yeah of course nothing because we still we use it for other things as well. So if there will be private messages to me in these topics they will be on whatever topics they'll be still be used to work. So yeah. But we have regulated by just fit in the flag right now. So it’s not a huge amount of support.
Ricardo: When supporting the other older version maybe we can inform the user that supporting it would cause more data usage. And then it could show the list of users that are using this other protocol and maybe you can ask them to update so you don't have to listen that.
Oskar: Igor and Andrea do you think from core point of view like is it do you have any thoughts like how to progress given that you want to reduce bandwidth with this one.
Andrea: At the moment we have you know some you know fairly big issue with reliability. So adding device device essentially communication not sure is a good idea. That's the thing you know like until we don’t know how to handle the outstanding issue this is just you  know a bit dangerous I think.
Igor: Yeah I agree and it's not that we have a pressing need to fix this partitioning topic like this week or something. But with more users is just more and more present. So it's just not that the current solution doesn't work, it just not scalable. So maybe we have some time to rethink it bit to give it a bit more of a thought. But maybe we can.
Oskar: Let's let's rethink it we can have bring this us up in the next core dev call as well. See if we have progressed in some dimension.
Jacek: Coming back a little bit to the user letting the user choose, I generally would consider that as fairly dangerous because or like from a security point of view tends to be a bad way to do it. One creative idea is to establish much longer time horizons on how fast these things change, so that the community has time to critique and review the change that's coming. And then like it's a little bit similar if you look at the thing what we're doing there is basically did we call this the week subjectivity which is a way to deal with long range attacks and the working theory is here that if somebody does something obviously bad done over a long period of time, it's socially feasible to overcome this say years or a year, months whatever, like that but but a fairly long period where the bad behavior has time to establish itself and therefore would be known through outside means If if we can. But what at least do basically is that the app needs to be able to support multiple protocols over extended period of time. And then the way to upgrade would well maybe we can hide it in an advanced option somewhere right but so that people can start trying these things and these new more efficient protocols for example but then also keep in mind when we develop things that that the overlap horizon or the overlap period should be considered to be fairly long and and and we should be able to provide you know a safer default for the user and then maybe switch that default and so on. And so as a way out from from from really bad decisions. I mean we do have the advantage that we're open and you know the code can be audited and so on, but then we also need this very long period of time for the information to seep out and sort of in case the code becomes tainted somehow, that there's time for this taint problem to become known even for people that are maybe not online all the time or more like you know that they know what kind of trend horizons we're looking at when we make these changes when they start using Dapps. So basically I know that alright if I start using status today, I know that for the sixth next six months, nothing's gonna change with the protocol and so on.
Igor: So do you think there is a reasonable time horizon for this kind of changes. For instance if we do still do a partitioning on topic it will still break compatibility but let's say we do not like one release but we do you like six releases or something before we actually activate it, so it means that the last six releases means three months or something already support this. So if you have a version that's older than three months and we're talking about beta right now. So yeah so is it like fine so we we implement it like right now releasing to these topics and then we implement some kind of yeah maybe like application of messages or something like this, so the old clients work and then like in three month or something we just disable older than three months fourth application.
Jacek: Well the time period is sort of a product decision maybe and it's a little bit of hard but the principle here is that when I start using Dapp, I would know that the guarantee will be upheld for this period of time. So I would also know how often I need to check whether something has changed. And generally like I think the period should be fairly long as in more than three months but you know that's really I don't have the data to just say that and then maybe  there's some way to figure that out or way things ended up with damages.
In these two were looking at half year probably at least and then we'll see but it still it still hasn't been discussed there because of the rather serious security sort of consequences if if you if you do the wrong thing here.
Oskar: By default six months seems reasonable to me it's with a lot of distro stuff as well. Unless they send a very strong arguments for either longer or shorter. 
Let's take it for another round and we can discuss these things and people can take on their own and then let's bring it up in code dev call and then we can move on unless there is something else people wanna say. 
Ricardo: It's difficult to kind of measure that's that kind of like we cannot enforce this this this should be only a suggestion because if there is a problem that is just making things not work it should be just change it sooner the possible. So yeah that would be.
Jakub: Because my question is how many people are actually using status outside of status as a company because if it's I don't know another 100 percent or 50 percent, is it really worth making achange that's much more difficult right now or in beta. I don't know if we have a metrics on how many actual users there are if we subtract status contributors.
Jacek: I don't think that matters. I think it's about establishing what status is in order to attract users and if we go about thinking like “Wo, we have 100 users, so we gonna break it”, that's not taking a reputation we think we necessarily want to have. Like we're making a stand here basically.
Jakub: And my point is depending on how much work you want to put it into the stand maybe it's better to just do the change about pouring as much, but that's my five cents.
Oskar: And if anyone else has anything to add, we move on.
Anna: I just two things from test team who actually using status very intensively. I don't know if I can survive for six more months without reliable messaging to be honest and I'm not sure that they will have a good reputation in eyes of users because we don't change protocol but is still not reliable in messaging let's yeah a bit of salt.
Oskar:  I think this is more about. 
Jacek: Yeah what I was gonna say is that the partition topic thing, it does not increase reliability al all. It's purely bandwidth 
Jacek: Which is also a thing that can affect how people view status if we're getting gigabytes of mobile data taken by our app that also affects how we were viewed. So that's the decision I guess.
Anna: Yeah I might be wrong telling that this is a problem if we all do it but in general if it will help to reduce issues with status, means messaging in status, this can change the history of I don't know how did chats if I am back after one day of not using status and it doesn't crash my mobile a lot, yeah it would be great. But again it's like like reality things that yeah we cannot say that we are good because we don't change protocol but at the same time maybe we need to be a bit I don't know look for other ways to be more realistic to please our users in ways that you know features are good, messaging is reliable, app does not crash because of too much data and so on. But again I understand that we need to build solid principles and culture right now, in the same time as a user I'm not yeah I will not be using this app if it will behave like this.
Andrea: The idea was to like changing the whole reason why we were actually partitioning the topic is that currently we're a bit limited but as pointed out the amount of data that we fetch. And so like therefore we only fetch the last 24 hours of data. So if you've been offline for more than 24 hours, you will miss messages. So although it's true that it does not affect reliability in terms of like you know like no more messages are going to be dropped by the transport layer than before, if you can if you can extend that period to 7 days, 14 whatever and we can only do that if the amount of data is manageable. There will be an impact on reliability that we gotta respect.
Oskar: So I would suggest we move on. I think this requires maybe more effort. Maybe we could put together some different proposals and then have some pros and cons and also then we can bring it up in next core dev call. Because I think that there are several ideas and that go either ways but they might need to be fleshed out a bit more whether it's sort of the timeframe recoverability or if we do a breaking change then should we have a path to recoverability, in some way we can limit the scope by creative solutions and so on. I think there is different sort of there's multiple options here that we can explore but it probably requires asynchronous effort. 
Ricardo: Yeah I agree with you. I just wanted to know who we should talk with to discuss this later on. 
Oskar: So I imagine Igor might want to do a few more runs on their post-mortem or whatever you want to call it pre-mortem, I don't know what you gonna call it, but then we can bring it up next core dev call and then we might we can also bring it up in a protocol call if that's interesting but I think.
Ricardo: So basically use the Disqus post in this meeting 
Igor: yeah I think Disqus is a good start and then we'll figure out from there. Because it's already a discussion started so there is no point to switch it somewhere else.
Oskar: All right. Cool. So we have maybe 20 more minutes So Ricardo, you had a brief announcement on topic democracy.
Ricardo: So tomorrow there is a meeting in the Status agenda that I'm going to present the swarm, what is the idea, that is being to the develop it in top democracy, basically how it works and why it works like this and so if you are interested in democracy and centralize the autonomous organizations and this can be used in many creative ways once it's created so might be interesting to many people.
Oskar: Cool. Pedro you want to talk briefly about exposing cells goers in next package.
Pedro: Yeah. So I think this is the the next logical step in terms of having reproducible builds. Right now we we host status code artifacts in digitalocean. So it's kind of a hand roll solution which really isn't required now that we have we hosted in this in this mix cache so we could just make status go another mix package and ideally also make the same the same approach that we took for status react does the same thing on status go so that people can just still do mix it up and mix takes care of all the dependencies and then that produces a next package which is uploaded to the next cache that we host and then that's what we use in Status react. So no more downloads during the the builds that are handled by us. It's a matter of consistency with all the other packages. I don't know if there's anything anything against this or if it's like logical for everyone. I don't know. It might be like for people who are working barely on Status Go that's maybe the people who will be more impacted by this. So it would just require that you do make shell and ensure that you're inside of this special shell from mix to build your app but it's not a big deal. You know from the experience with Status React, it's not a deal breaker. But I would be interested in hearing if there is anything against going forward with this.
Igor: No just one question. Is there so when we publish a new version it just get auto-published immediately or do it, how does it work because right now a publisher just when you have for instance and it's like there is no approval process, nothing like this and if we add it to the mix as a new version,
Pedro: Well in the recipe, So Status React it has these these mix files, so you would determine there one basically in the same way isn't where we change Status Go version file in Status React. Instead of doing it there you would do inside your mix recipe saying, “Okay, I want to use this hash of of telesco” and then it will either build it or download from the cache but it would do so in very reproducible way.
Igor: Okay so we are not independent, so it will build it in case there's this cache doesn't exist in this cache. Okay so it also solves the issue with your local builds right?
Pedro: Yeah if you want to test like your special branch in Status Go, then makes it easier also.
Igor: Then I don't say there is any reason not to do it. 
Pedro: Okay cool. Okay so if there's no more input on this I'll move forward.
Oskar: Unicorn update. Maybe Anna or Igor, do you want to take the things from the app point of view.
Anna: Yeah I guess, if you can hear me probably yes. So we like have the last change to be integrated at least for mobile app. Unfortunately for desktop I I will need Vitali's help to talk about the progress there because again we have desktop used to communicate and mobile. So for mobile we are almost ready. For desktop honestly I'm not sure yet. So if Vitali is in the meeting please tell about about it if not and probably will need to sync right after this. But again for desktop it's a bit easier because they don't need any Apple approval process in test flight etc. So they can they do have a bit more time to to make a release.
Oskar: It's also fine like if it's not working right that's something that people can hack on during the day or just for today I'm afraid that if you don't have possibility to tear the custom but not on my server you will not be able to hack a lot in desktop in that day but yeah so I mean that during the day then people can add that. 
Anna: Yeah. Let's see. So yeah it will be like there will be couple of like very basic warning like several unicorns shown to you in pop up with the details button that goes to that blog post from you Oscar. I feel like we will need a bit more user like simple user oriented messaging like- “okay you will not be able to send transaction”, “you will have like internal server error”, “I will not see a transaction history” and blah blah blah but in general yeah. Also after after we add the last must changed mobile app as Adam suggested, we might probably not might, but we will test also on staging fleet and just to have complete end-to-end scenario on like in in the play and see that actually it works without affecting beta fleet, so without affecting our users who use releases and nightlies - and as I said, again it's it's one day, so yeah it will be a bit ugly I mean this pop-up, warning, and yeah it will give you a feeling on what is the world results centralized services and how you can do with this and what you can do to actually make it work in any way. So yeah let's see. If Igor if you want add or Vitali, please do.
Igor: Yeah I had a proposal that since we wanted to discuss it like on Friday but since Oscar is here and everyone is here I want to do a proposal that we start this unicorn day not at midnight but at some time a bit later than this when most of the contributors are woken up at least maybe at 8 or 9 central european time to start the recording from there. Just to like because the first few hours would be the most.
Oskar: The proposal is 9 a.m. to UTC.
Igor: Oh, it’s 9 am, I thought it zero, it was like midnight.
Oskar: Oh, it was 2 - sorry I I was I wrote two times. That's 
Igor: Ok if it's 9 a.m. you see then it's perfect. 
I just wanna check, so is it correct that even if you are using an old version because the Cluster will be shut down in such a way that it still won't work. So people can treat by using old version. Is that correct?
Igor: Infura no. 
Oskar: Infura, yeah I meant no.
Igor: The cluster will be just shut down yes that's you know compared I think it's like this Michael
Oskar: And then there's some awesome guides by Bruno and Chuck and maybe some others as well on how to run your node. So if you don't have anything to do in a weekend or on Monday you can set up as well. Anyone have anything else on 
Oskar: Right so just super briefly quick follow-up on the better PR process so what I call was for six weeks ago. So the first question is just do people feel like things are better is it different or yeah what's the general impression?
Ricardo: I'm liking, I mean very meaningful I think, useful.
Oskar: Cool. Anyone else? or has it .. yeah 
Anna: I can talk from testing perspective so we still don't have this separate column for ready for auto tests or whatever. Probably just because the mix PR was to be Igor and Anton need to like need to work together on this. I think several times Anton, but I still don't see this home and again I'm not sure Pedro if you can shed some light on this because right now it's not practical to expect that on review stage. We will have all the tests run. Again because of different reasons I don't want to count them right now but actually it's not happening. So we have the review, we are expecting that auto tests will be run there. They don't so extra test team right now manually runs them, for each PR. That is.. Yeah.
Pedro: Yeah I remember there was an issue yeah unfortunately it's been like three or four weeks since I last touched that's so I don't recall the exact reasons. But yeah there's there's a lot of situations which which can go wrong in the in triggering that but basically I need to have some time to to look into it, again and figure out what was the issue. 
Anna: But I think we just we're trying to find the like someone who can add this separate extra step, a separate column for like ready to be ready for auto tests, and also only Oskar who has rights, I don't know
Oskar: Wait wait. I cannot, you want a column in the QA.
Anna: yes.
Oskar: Okay. I think there should be a bunch of people Igor, I can help now but I think Igor and Jacob should also have permissions. Let me let me add it now. Could you could you message me what you wanted?
Anna: Okay yeah I look just let me also sync with Pedro it it was the final solution, because I remember it was like a step where I just I stopped following 
Pedro: Okay and then we didn't also need to customize that column name in instead Status React reacts in dot github directory. bBut at least well instead of Atari is already in place.
Oskar: See if you block just just be me, I think that Igor, Jacob and I should all have permissions for this. But 
Igor: I think I have permissions for this.
Oskar: Yeah I think so maybe not I'm not sure how that means things work on the github. Okay and then I guess to us a brief maybe if there's some very follow up or comment on the products both Andrea and Anton mentioned it in the in their PM front, but for other people, do you want to briefly mention there's this state of of that research and like possible next steps? 
Andrea: Can do so. I looked into basically being able to test the app without you know like essentially order you I could. So it is technically possible you will need two separate processes completely because refrain database it's like a single one and you know we definitely want to test some of the frame logic because it's the most complex. You would need to basically touch everything you know from components from the UI components at the moment is a bit coupled and so that requires a bit of refactoring. After that you are able to run and to purchase processes inside a docker container and so that's where you see what I got. It is possible at the moment you know like I haven't separated the components and therefore is like the resulting docker images or lists you know like the docker not docker image but just the Dex Dex file is 400 megabytes big. But that's because of the UI dependencies pulled in. You can do that and on top of that you could do something of a testing framework essentially and run two instances of case and then checking the results. It requires considerable effort. At the moment I don’t really have the bandwidth to explore any further.
I don't think the investment of time with you yeah 
Oskar: Do you think it's something for the core backlog or it doesn’t make sense to make like a big bounty of it if someone figures out a way to ..
Andrea: I mean you know if there's a bounty, I mean you know like it's not something that is so critical I mean even if it doesn't work perfectly it's it's fine. So like it's definitely bounty material you know whether someone will you know be able to do it it's it's different I mean.
Oskar: dDo you think you could write it up in a in a github issue and and then we can put a bounty on it.
Andrea: Yeah. Yes good idea. 
Eric: Correct me if I'm wrong but the idea of separating logic and views as much as possible would help a lot with that right? Because then we won't have we won't need views at all. You could just do with descriptions and dispatch right?
Andrea: Yes definitely definitely you know. I don't know if that is all we need but Stefan is something that we definitely need.
Oskar: Yeah we can I think we will make a bounty in a week and maybe that sort of things we can factor out .Like there's some refactoring task if that's seen as a blocker whatever. Then we can see what other contributors what matter if they can work. And we can maybe bring it up in general core call or quarter call later. 
All right Anton, do you have anything you want to say on the automated testing side of things.
Anna: Anton is not in the call, but he updated me. Yeah so basically IS testing is ready. It can be run locally but this issue is our Sole labs provider. A way we run our tests like for PRs for nightlies etcetera. And it doesn't work there. There is extensive description like what is the problem? Basically it starts, this the launching app takes like eight minutes or so and it's unusable in this state. So we waiting for customer support from Sole labs to yeah solve this issue and it's almost like two weeks since we are looking at it. 
Oskar: Did we did we ping them and also does anyone else have this problem?
Anna: The problem is that it's only for Status app. There are like other apps. It works fine. So there is something specific to our app and they don't tell what they don't tell what is exact problem but they say yeah we are looking into it, our dev team it is looking into it. There's not like some customer support guy you know playing this rounds of checklists they have. It's really like already moved to to the dev team, and dev team doesn't give any clue on what it is and when it will be fixed etc. So it was March 12th, now it's yeah it's not like exactly two weeks but almost two weeks. 
Oskar: Did we look into possible alternatives to Sole labs as well?
Anna: Actually Anton is looking like again we are waiting for this but meanwhile he also was looking into what we can do in other providers like Browserstack for example but it will again take some time to migrate there. So but yeah se we prefer to get the final answer from dev team before we move in somewhere.
Oskar: Okay awesome. This might also be a good topic for Disqus because I think there's probably people within status community that have experience with this setup as well that might have some ideas. 
Anything else on PR process?
Any quick announcements before we end this call?
Eric: If you're a European call your MPs to vote against article 13.
Oskar: Alright. Cool.
Barry: Just for those of us who are not in Europe, could you post something in Watercore or something that explains what that is.
Oskar: Yeah, that will be great. I pasted something. And then if you if you want to please feel free to rate this call on a scale from one to ten with any comments on how to be improved and posted it in status core devs. If there isn’t something else, I think we can finish this up.
Right. Cool. Thanks everyone for joining and see you in 2 weeks. Bye.
Hester: Thanks everyone. Bye bye.

